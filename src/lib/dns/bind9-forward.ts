import { exec } from 'child_process';
import { writeFile } from 'fs/promises';
import pool from '@/db';
import type { DnsForwardZone } from '@/types';

const FORWARD_CONF_PATH = process.env.BIND9_FORWARD_CONF || '/etc/bind/named.conf.forward';
const RESTART_CMD = process.env.BIND9_RESTART_CMD || 'systemctl restart named';

export interface ForwardZoneSyncResult {
  success: boolean;
  skipped: boolean;
  message: string;
  config: string;
}

/**
 * Generate named.conf snippet for all active forward zones.
 */
export function generateForwardZoneConfig(zones: DnsForwardZone[]): string {
  if (zones.length === 0) {
    return '// No forward zones configured\n';
  }

  const blocks = zones.map((zone) => {
    const ips = zone.forwarders
      .split(',')
      .map((ip) => ip.trim())
      .filter(Boolean);
    const forwardersList = ips.map((ip) => `        ${ip};`).join('\n');

    return [
      `zone "${zone.name}" {`,
      '    type forward;',
      `    forward ${zone.forward_policy};`,
      `    forwarders {\n${forwardersList}\n    };`,
      '};',
    ].join('\n');
  });

  return `// Auto-generated by NavStation DNS manager\n// Do not edit manually\n\n${blocks.join('\n\n')}\n`;
}

/**
 * Read active forward zones from DB, generate config, write file, restart BIND9.
 * Updates sync status on all forward zones.
 */
export async function syncForwardZones(): Promise<ForwardZoneSyncResult> {
  const { rows: zones } = await pool.query<DnsForwardZone>(
    `SELECT * FROM dns_forward_zones WHERE is_active = true ORDER BY name ASC`
  );

  const config = generateForwardZoneConfig(zones);

  if (process.env.BIND9_DRY_RUN === '1') {
    // Mark all active zones as skipped
    await updateAllSyncStatus('skipped', 'BIND9_DRY_RUN=1, skipped write & restart');
    return {
      success: true,
      skipped: true,
      message: 'BIND9_DRY_RUN=1, skipped write & restart',
      config,
    };
  }

  try {
    await writeFile(FORWARD_CONF_PATH, config, 'utf-8');
  } catch (error) {
    const msg = `写入配置文件失败: ${(error as Error).message}`;
    await updateAllSyncStatus('failed', msg);
    return { success: false, skipped: false, message: msg, config };
  }

  try {
    await execCommand(RESTART_CMD);
  } catch (error) {
    const msg = `重启 BIND9 失败: ${(error as Error).message}`;
    await updateAllSyncStatus('failed', msg);
    return { success: false, skipped: false, message: msg, config };
  }

  await updateAllSyncStatus('success', '同步成功');
  return { success: true, skipped: false, message: '配置已写入并重启 BIND9', config };
}

async function updateAllSyncStatus(status: string, message: string) {
  try {
    await pool.query(
      `UPDATE dns_forward_zones
       SET last_sync_status = $1,
           last_sync_message = $2,
           last_synced_at = NOW(),
           updated_at = NOW()
       WHERE is_active = true`,
      [status, message]
    );
  } catch (error) {
    console.error('Failed to update forward zone sync status:', error);
  }
}

function execCommand(cmd: string): Promise<string> {
  return new Promise((resolve, reject) => {
    exec(cmd, { timeout: 30000 }, (error, stdout, stderr) => {
      if (error) {
        reject(new Error(`${error.message}${stderr ? `\n${stderr}` : ''}`));
        return;
      }
      resolve(stdout);
    });
  });
}
